#include <iostream>
#include <time.h>
using namespace std;

struct Player {
    int hp;
    int damage;
};

int main()
{

    // 지금까지 사용한 방식
    // number라는 이름의 4바이트 바구니를 생성
    // number 변수는 스택 메모리에 할당
    // number라는 바구니에 1이라는 값을 넣음
    // 변수는 모두 바구니이고 바구니마다 주소가 있고 바구니안에는 어떤 값을 저장할수있다.

    int number = 1;

    // 다른 함수에서 main함수내에서 선언된 지역변수인 number를 조작할수없다.
    // 이떄 포인터 변수를 이용하면 그것이 가능하다.


    // 포인터는 주소를 저장하는 바구니이다.
    // 즉 바구니들의 주소에 접근할수있다.
    // *변수이름 >> 지역변수의 주소록에 접근하여 그 주소에 해당되는 바구니 안의 값까지 조작가능하다.
    // 주소값을 저장하는 포인터도 자기자신의 주소값이 있으며 
    // 포인터의 주소를 저장하는 것이 이중포인터이다.
    // 포인터라는 바구니는 4바이트 or 8바이트 고정크기이다.

    int* ptr;        // 포인터 변수의 선언

    ptr = &number;   // ptr에게 number바구니의 주소를 가리키도록 한다.

    *ptr = 2;        // *ptr은 가리키고 있는 주소의 바구니 안에 있는 값을 2로 변경한다.


    // 포인터 변수의 타입

    // 포인터 변수를 어떤 주소로 지정하고나서
    // *P 문법을 이용해 값을 조작할때 
    // type이 일치해야 올바른 조작이 가능하기 떄문에
    // type을 맞춰 주어야한다.

    //////// 포인터 연산

    //// 1) 주소 연산자(&)


    //// 2) 산술 연산자

    // (+ -)

    number += 1;  // 1증가


    // ptr += 1;   // 주소가 4증가했다?

    // 포인터에서 1을 더하거나 뺴는 것은 
    // (type의 크기)x 1 만큼 이동하라는 의미
    // 다음 주소로 1번 넘어가라는 뜻이다.
    // 바구니 단위의 이동

    //// 3) 간접 연산자(*)

    // 간접참조를 할 수 있는 연산자
    // 포탈을 타고 써있는 주소로 이동!

    *ptr = 3;    // number = 3; 과 같은 효과를 낸다.

    //// 4) 간접 멤버 연산자(->)

    Player P1;
    P1.hp = 100;
    P1.damage = 10;

    Player* P1ptr = &P1;

    // 구조체 포인터에서 간접 연산자 사용시  (*P1ptr).hp = 100 ; 
    // * 과 . 을 합쳐서 -> 로 표현 
    // structPtr -> hp = 100 ;   으로 표현가능

    (*P1ptr).hp = 200;

    P1ptr->damage = 20;

    return 0;
}
