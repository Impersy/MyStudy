#include <iostream>
using namespace std;

// 어셈블리 언어 입문

 
////  데이터 기초
// 비트와 바이트
// 
// 비트는 0 과 1만 가질 수 있는 단위
// 1 바이트 = 8 비트
// 
// 0 0 0 0 0 0 0 0 > 바이트(8비트)
// 가장 왼쪽은 음수부호(값도 가지고 음수를 만드는 역할도 한다)
// 시작자리값은 1이고 왼쪽으로 갈수록 2배씩 증가
// 
// HEX  16진수    0 1 2 3 4 5 6 7 8 9 A B C D E F 10 11 12 13 ~ (0x00)
// DEC  10진수    0 1 2 3 4 5 6 7 8 9 10 11 12 ~ 
// OCT  8진수
// BIN  2진수     0 1 10 11 100 101 110 111 1000 1001 ~ (0b00)
//
// * 2진수를 4개씩 끊어서 읽으면 16진수로 바꾸기 편하다.
//   0b10101101 > 1010 / 1101  > 0xAD
//
// * 2의 보수 > 01010110(86) 을 부호만 바꾸려면 10101001 로 바꾼 후 +1 해주면 되므로 10101010 이 -86이다
//

////  레지스터 기초
// CPU안에 ALU와 가장 근접에 있는 저장장치 
// 요즘은 보통 레지스터의 크기는 64비트다
// 주로 eax ebx ecx edx 이렇게 사용 이외에 여러가지 종류 많음
// 사용범위에 따른 용어
// rax 64
// eax 32
// ax  16
// ah al 8
//
// mov 명령어
// mov reg1,cst   - cst값을 reg1으로 이동
// mov reg1,reg2  - reg2값을 reg1으로 이동
//
// 레지스터 사용범위에 따른 주의사항
// rax에 0x1234 가 들어있는 상황에서
// mov al,0x00 을 실행하면 부분적으로 건드리기 때문에 0x1200이 된다.


////  변수의 선언 (메모리에 올라감)
// 
//  초기화된 데이터는 data 영역에 올라감
// 
//  [변수이름] [크기] [값]
// 
//  db(1) dw(2) dd(4) dq(8) 
// 
//  a db 0x11
//  b dw 0x2222
//  c dd 0x33333333
//  d dq 0x4444444444444444
// 
//  초기화되지 않은 데이터는 bss 영역에 올라감
// 
//  [변수이름] [크기] [개수]
//  
//  resb(1) resd(2) resw(4) resq(8)
// 
//  e resb(1) 10
//


//// 레지스터와 메모리
// 메모리는 변수를 만들면 주소를 할당하여 그 부분에 값을 저장한다.
// a라는 변수는 그냥 이름일 뿐이고 실제로는 메모리의 주소가 본체이다.
// mov rax, a 를 실행하면 a라는 바구니 안에 값을 복사해주는게 아니고
// rax에는 a의 주소값이 들어가게 된다
// 
// mov rax, [a] 이렇게 쓰면 a바구니안에 값을 레지스터에 복사해주게 된다.
// 0x11이 들어와야 정상이지만 시작주소로부터 얼마만큼 크기까지가 원하는 값인지 데이터의 크기를 지정을
// 안해주어 rax의 크기인 8바이트 만큼 전부 가져오게된다.
// mov al, [a] 이렇게 하면 1바이트만큼만 가져올것이다
// 
// 레지스터에서 메모리로 가져오는 것도 당연히 가능하다.
// mov [a], cl
// mov [a], byte 0x34 (수를 직접 넣을땐 크기를 꼭 지정)



//// 문자와 엘디안
//  
//  메모리에 저장되는 정보는 어떤 관점으로 보냐에 따라 
//  달라지기 때문에 10진수인지 16진수인지 2진수인지 잘 생각해야한다.
//  또한 문자를 쓸 때도 어떤 숫자를 어떤 문자로 볼지 아스키코드같은 조약을 
//  통해 사용한다. 
// 
//  엘디안
//  리틀/빅
//  빅은 메모리 주소가 증가하면 데이터도 그 방향으로 저장
//  리틀은 메모리 주소와 반대되는 순서로 저장
// 
//  각각의 장단점이 있다.
// 
//





































