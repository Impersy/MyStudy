#include <iostream>
using namespace std;

// ctrl + K + C 주석달기 , ctrl + K + U 주석풀기


#pragma region 정수형변수
//// "정수형 변수"

int hp = 100;

char a3;        // 1바이트 (-128~127)
short b3;       // 2바이트 (-32768~32767)
int c3;         // 4바이트 (-21.4억~21.4억)
__int64 d3;     // 8바이트 (long long) (+-경,해 단위)

unsigned char a1;        // 1바이트 (0~255)
unsigned short b1;       // 2바이트 (0~65535)
unsigned int c1;         // 4바이트 (0~42.8억)
unsigned __int64 d1;     // 8바이트 (long long) (0~경,해 단위)

// 콘솔/모바일 게임은 메모리가 항상 부족 >> 되도록이면 바이트를 줄이는게 좋음

// 범위를 벗어나게되면 정수 오버플로우 언더 플로우 발생
#pragma endregion

#pragma region 실수형변수
//// "불리언과 실수형"

// 불리언 bool >> 참 또는 거짓 (1 또는 0)

bool isHigh = true;
bool isWoman = true;
bool isMan = false;

// bool 도 사실 1바이트 정수에 불가
// 그런데 왜 정수형에서 안다룰까? ..일리있는말
// bool만 봐도 참 또는 거짓이라는 힌트를 준다.
// 굳이 8비트인 이유?? 사실 1비트면 되지만 최하위 단위가 1바이트라서 그럼


// "실수형"

float fl = 2.12f;     // 4바이트      (float로 인식시킬려면 끝에 f)

double dob = 3.1230024;  // 8바이트

// 실수표현방법 >> 부동소수점 : 뜰(부) 소수점을 유동적으로 이동시켜 사용

// 3.1415926535 = 0.31415926535 x 10^n (n=1)
// 31415926535 = 유효숫자 , n = (지수)

// float >> 부호(1비트) + 지수(8비트) + 유효숫자(23비트) = 32비트 = 4바이트
// double >> 부호(1비트) + 지수(11비트) + 유효숫자(52비트) = 64비트 = 8바이트

// 프로그래밍할떄 부동소수점은 항상 '근사값'이다.
// 수가 커질수록 오차범위도 커진다.
// 실수 2개를 == 으로 비교하는 것은 조심
#pragma endregion

#pragma region 문자와문자열
//// 문자와 문자열

// char : 알파벳,숫자 
// wchar_t : 유니코드 문자

// 아스키코드 (문자를 숫자로 변환한 코드)
char ch = 97;   

// 문자의 의미로 ' ' 사용

char ch1 = 'a';     // 문자 a를 의미한다.
char ch2 = '1';     // 아스키코드로는 숫자 1이 저장 x  문자 1 을 나타냄

char ch3 = 'a' + 1;  // 문자 b를 의미한다


// 전세계 모든 문자에 유일코드를 부여한 것이 유니코드

// 유니코드는 표기방식이 여러가지 그중 utf8 / utf16

// UTF8
// 알파벳,숫자 = 1바이트
// 유럽지역은 = 2바이트
// 한글,한자= 3바이트

// UTF16
// 알파벳,숫자,한글,한자 = 2바이트
// 특수고대문자만 4바이트


wchar_t wch = L'가';      // L을 앞에 붙여줘야함


// Escape sequence
// 표기하기 애매한 애들 표현

// \t = 아스키코드9 = Tab
// \n = 아스키코드10 = Linefeed (줄바꿈)
// \r = 아스키코드13 = 커서를 맨처음으로 이동
// ' ' 안에 '를 넣고 싶을때 '''  이면 어디서 끝나는지 애매하니깐 '\'' 이렇게 표현

// 문자열

// 문자들이 열을 지어 모여있음 
// 문자열 끝은 항상 \00(NULL) 이 있어야함

char str[] = { 'H','E','L','L','O','\0'};

char str2[] = "HELLO";   // 자동으로 끝에 NULL 포함
#pragma endregion

#pragma region 전역변수 데이터영역
//// 메모리구조 - [데이터 영역]

    // .data (초기값 있음)
int s = 2;

// .bss  (초기값 없음)
int g;

// .rodata (읽기 전용)
const char* msg = "hello world";

// main 함수 밖에서 정의하는 변수를 전역변수라고함
#pragma endregion

int main()
{

#pragma region wcout
    
    cout << ch << ch1 << endl;


    cout << wch << endl;      
    // 한글로 안나오고 숫자로 나옴

   // cout 은 char 전용이라 wcout 이 한국어를 인식하게 해야함
    wcout.imbue(locale("kor"));
    wcout << wch << endl;  
#pragma endregion    


#pragma region 산술연산
    int a, b = 0;

    //// 산술연산

    // 1.대입연산

    a = b;  // b에 있는 값을 a에 넣는다.

   // b에 있는 값을 a에 복사하고 b를 반환

    a = b = 3;   // (b = 3)을 하고 b(3)를 반환 그 후 a = 3 실행

    // 2.사칙연산

    // ex) 데미지 계산,방어력 계산 등등

    a = b + 3;
    a = b - 3;
    a = b * 3;
    a = b / 3;
    a = b % 3;

    a = a + 3;
    a += 3;
    // 2개는 똑같은 식임


    // 증감연산자
    a++;    // 문장을 실행하고 1증가
    ++a;    // 먼저 1증가시키고 문장실행

    b = a++;    // b=a  >> a++
    b = ++a;    // a++  >> b=a


#pragma endregion


#pragma region 비교연산

    // 언제필요?
    // 체력이 0 이하면 사망,데미지가 몇 이상이면 즉사 등등

    // a==b   : a와b 가 같나? 같으면 1 다르면 0

    // a!=b
    // a>b a>=b
    // a<b a<=b



#pragma endregion


#pragma region 논리연산

    // 조건에 대한 논리적 사고가 필요할때

    // AND OR NOT  이용


    // ! (NOT)
    // 0이면 1로 1이면 0

    // && (AND)
    // (~~) && (~~)  둘다 1이면 1 아니면 0


    // || (OR)
    // (~~) || (~~) 둘다 0이면 0 아니면 1

#pragma endregion


#pragma region 비트연산

    // 비트단위의 조작이 필요할때 사용
    // 비트 플래그

    // ~ bitwise not
    // 모든 비트를 대상으로 0은 1로 1은 0으로 바꿈

    // & bitwise and
    // 비트를 쌍으로 비교하여 두 숫자가 둘다 1이면 1 아니면 0

    // | bitwise or
    // 비트를 쌍으로 비교하여 두 숫자의 둘 중 하나라도 1이면 1 아니면 0

    // ^ bitwise xor
    // 비트를 쌍으로 비교하여 두 숫자가 같으면 0 다르면 1

    // << 비트 좌측 이동
    // 비트열을 n만큼 왼쪽으로 이동
    // 왼쪽에 넘치는 n개의 비트는 버린다. 새로 생성되는 n개의 비트는 0으로 저장

    // >> 비트 우측 이동
    // 비트열을 n만큼 오른쪽으로 이동
    // 오른쪽에 넘치는 n개의 비트는 버린다.새로 생성되는 n개의 비트는
    // -부호비트가 존재할 경우 유의해야함 
    // -아니면 0


    // 실습 (비트 플레그)

    // 0b0000 [무적][변이][스턴][공중에뜸]

    // Ex) 0b1100 >> 무적,변이 상태

    unsigned char flag;   // -부호비트 제거

    // 무적 상태
    flag = (1 << 3);  // 1(0b0001) 을 왼쪽으로 3번 쉬프트 (0b1000)

    // 변이 상태 추가
    flag |= (1 << 2); // 0b1000 과 0b0100 을 | 하면  0b1100

    // 무적인지 확인(다른 상태는 관심 없음)
    // bitmask

    bool invincible= ((flag & (1 << 3)) != 0);

    // 무적이거나 스턴인지 확인
   
    bool stunOrinvincible = ((flag & 0b1010) != 0);


#pragma endregion


#pragma region const

    // 하드코딩을 하게 되는 경우 (1<<3) 처럼 그냥 3같은 수를 박아놓으면
    // 코드를 수정할때 불편한 상황이 많이 나온다.

    // 한번 정해지면 절대 바뀌지 않을 값들
    // constant의 약자인 const를 붙인다.(변수를 상수화 한다)
    // const를 붙이면 초기값을 반드시 지정해야함

    const int AIR = 0;
    const int STUN = 1;
    const int POLYMORPH = 2;
    const int INVINCIBLE = 3;

    // 의미가 있는 숫자들이 이름을 가져 가독성 증가
    // 그러나 누군가 이 변수값을 바꿀수도 있기 때문에
    // const를 붙여줘야 변경할 수 없다
#pragma endregion


#pragma region 지역변수 stack영역

    // 함수내에서 정의하는 변수는 지역변수라 하고
    // 이들은 스택메모리의 스택프레임에 일시적으로 저장되고 함수호출이 끝나면
    // 더 이상 유효하지 않다.
    // 그래서 함수호출이 끝나고 stack프레임에 접근하는 것은 주의해야한다.
#pragma endregion 


#pragma region 유의사항

    // 1. 변수의 유효범위

    // 전역변수는 유효범위가 없다시피 하지만
    // 지역변수는 복잡해진다.
    
    // 스택에 있는 변수는
    // {} 중괄호가 생존범위이다.
    // 생존범위내에서 같은 변수의 이름을 중복사용하면 안된다.

    // 2. 연산 우선순위
    // 강제적으로 ()를 이용해서 순위를 정해주면 된다.


    // 3. 타입 변환
    // 바구니 교체

    int t = 3;

    // 캐스팅
    short t2 = (short)t;
    float t3 = (float)t;

    // 만약 t가 77777같은 큰 값일 경우 short로 변환하면 t2는 12241이라는 
    // 엉뚱한 값이 나옴 4바이트>>2바이트 이므로 위에 2바이트는 날아가버리기때문

    // 정수형에서 실수형으로 변환할때도 정밀도 차이로 오차가 난다.


    // 4. 사칙연산 관련

    // 너무 큰 값끼리 곱하면 오버플로우 발생할 수 있다.
    // 0으로 나누는 것은 오류가 남.
    // 정수/정수 = int로 나옴 , 정수/실수 나 실수/정수는 float형으로 나옴




#pragma endregion 



    // 다시 빠르게 복습 
   return 0;
}





