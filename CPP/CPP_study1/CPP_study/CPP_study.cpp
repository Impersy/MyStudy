#include <iostream>
using namespace std;

// 어셈블리 언어 입문 (SASM)

 
////  데이터 기초
// 비트와 바이트
// 
// 비트는 0 과 1만 가질 수 있는 단위
// 1 바이트 = 8 비트
// 
// 0 0 0 0 0 0 0 0 > 바이트(8비트)
// 가장 왼쪽은 음수부호(값도 가지고 음수를 만드는 역할도 한다)
// 시작자리값은 1이고 왼쪽으로 갈수록 2배씩 증가
// 
// HEX  16진수    0 1 2 3 4 5 6 7 8 9 A B C D E F 10 11 12 13 ~ (0x00)
// DEC  10진수    0 1 2 3 4 5 6 7 8 9 10 11 12 ~ 
// OCT  8진수
// BIN  2진수     0 1 10 11 100 101 110 111 1000 1001 ~ (0b00)
//
// * 2진수를 4개씩 끊어서 읽으면 16진수로 바꾸기 편하다.
//   0b10101101 > 1010 / 1101  > 0xAD
//
// * 2의 보수 > 01010110(86) 을 부호만 바꾸려면 10101001 로 바꾼 후 +1 해주면 되므로 10101010 이 -86이다
//

////  레지스터 기초
// CPU안에 ALU와 가장 근접에 있는 저장장치 
// 요즘은 보통 레지스터의 크기는 64비트다
// 주로 eax ebx ecx edx 이렇게 사용 이외에 여러가지 종류 많음
// 사용범위에 따른 용어
// rax 64
// eax 32
// ax  16
// ah al 8
//
// mov 명령어
// mov reg1,cst   - cst값을 reg1으로 이동
// mov reg1,reg2  - reg2값을 reg1으로 이동
//
// 레지스터 사용범위에 따른 주의사항
// rax에 0x1234 가 들어있는 상황에서
// mov al,0x00 을 실행하면 부분적으로 건드리기 때문에 0x1200이 된다.


////  변수의 선언 (메모리에 올라감)
// 
//  초기화된 데이터는 data 영역에 올라감
// 
//  [변수이름] [크기] [값]
// 
//  db(1) dw(2) dd(4) dq(8) 
// 
//  a db 0x11
//  b dw 0x2222
//  c dd 0x33333333
//  d dq 0x4444444444444444
// 
//  초기화되지 않은 데이터는 bss 영역에 올라감
// 
//  [변수이름] [크기] [개수]
//  
//  resb(1) resd(2) resw(4) resq(8)
// 
//  e resb(1) 10
//


//// 레지스터와 메모리
// 메모리는 변수를 만들면 주소를 할당하여 그 부분에 값을 저장한다.
// a라는 변수는 그냥 이름일 뿐이고 실제로는 메모리의 주소가 본체이다.
// mov rax, a 를 실행하면 a라는 바구니 안에 값을 복사해주는게 아니고
// rax에는 a의 주소값이 들어가게 된다
// 
// mov rax, [a] 이렇게 쓰면 a바구니안에 값을 레지스터에 복사해주게 된다.
// 0x11이 들어와야 정상이지만 시작주소로부터 얼마만큼 크기까지가 원하는 값인지 데이터의 크기를 지정을
// 안해주어 rax의 크기인 8바이트 만큼 전부 가져오게된다.
// mov al, [a] 이렇게 하면 1바이트만큼만 가져올것이다
// 
// 레지스터에서 메모리로 가져오는 것도 당연히 가능하다.
// mov [a], cl
// mov [a], byte 0x34 (수를 직접 넣을땐 크기를 꼭 지정)



//// 문자와 엘디안
//  
//  메모리에 저장되는 정보는 어떤 관점으로 보냐에 따라 
//  달라지기 때문에 10진수인지 16진수인지 2진수인지 잘 생각해야한다.
//  또한 문자를 쓸 때도 어떤 숫자를 어떤 문자로 볼지 아스키코드같은 조약을 
//  통해 사용한다. 
// 
//  엘디안
// 
//  리틀/빅 엘디안
// 
//  빅은 메모리 주소가 증가하면 데이터도 그 방향으로 저장
//  리틀은 메모리 주소와 반대되는 순서로 저장
// 
//  각각의 장단점이 있다.
// 
//  빅은 숫자 비교에 용이하다.
//  리틀은 캐스팅에 용이하다.
// 
//


//// 사칙연산
// 
//  더하기/뺴기
//  add a,b (a=a+b)
//  sub a,b (a=a-b)
// 
//  a 는 레지스터 or 메모리
//  b 는 레지스터 or 메모리 or 상수
// 
//  단! a,b 모두 메모리 는 안됨
// 
//  곱하기/나누기는 굳이 알 필요는 없다.
//


//// 시프트 연산과 논리 연산
// 
//  // shift 연산 >> shl / shr
// 
//  왼쪽으로 비트를 한칸씩 밀거나
//  오른쪽으로 비트를 한칸씩 민다.
// 
//  단, 오른쪽으로 밀때는 최상위 비트가 1일때 그 자리가 1로 유지된다.
// 
//  왼쪽으로 시프트연산을 1칸 하는것은 음수가 아닐 시 x2 를 하는 것과 같음
//  
//  // 논리 연산 
// 
//  AND (둘다 1이면 1)
//  OR  (둘중 하나라도 1이면 1)
//  NOT (1이면 0 0이면 1)
//  XOR (서로 다르면 1)
// 
// 
// 
//

//// 분기문
// 
//  CMP dst, src 
// 
//  비교한 결과물은 eFlag Register에 저장
// 
//  JUMP [label] 시리즈
// 
//  JMP 무조건 점프
//  JE  같으면 점프
//  JNE 다르면 점프
//  JG  크면 점프
//  JGE 크거나 같으면 점프
//  JL  작으면 점프
//  JLE 작거나 같은면 점프
// 
//  이 점프 명령어를 통해 코드를 원하는 라벨위치로 점프하게 
//  만들어서 코드의 흐름을 조절한다.
// 
// <1~100 까지 숫자가 짝수이면 1 홀수이면 0 을 출력하는 시스템>
//  mov ax, 90
//  mov bl, 2
//  div bl  (나누기는 ax / bl 이렇게 되고 몫은 al 나머지는 ah 에 저장된다)
//  cmp ah, 0
//  je  Le
//  mov rcx, 0
//  jmp Lne
//  Le :
//      mov rcx, 1
//  Lne :
//      PRINT_HEX 1, rcx
//

//// 반복문
// 
// <1~100 까지 수를 더하는 프로그램>
// 
//  mov eax, 100
//  mov ebx, 0
//  mov ecx, 0
// 
//  LABEL_SUM:
//     inc ecx
//     add ebx, ecx
//     cmp ebx,eax
//     jne LABEL_SUM
// 
//  PRINT_DEC 4, ebx
//  NEWLINE
// 
//  이렇게 라벨을 이용해 코드흐름을 뒤로 점프하게하여 
//  반복적인 일을 수행한다.
// 
// 
// 



//// 배열과 주소
// 
//  배열 : 동일한 타입의 데이터 묶음
//  배열의 구성하는 각 값 > 배열 요소 (element)
//  배열의 위치를 나타내는 값 > index
// 
//  a db 0x01, 0x02, 0x03, 0x04, 0x05 
//  b times 5 dw 1 (2byte짜리 5개 , 초기값은 1)
// 
//  배열의 이름은 배열의 첫번째 위치의 주소값이다.
//  a 와 b는 그 배열의 첫번째 주소값을 나타낸다.
//  
//  첫 주소값을 기준으로 배열요소의 크기만큼씩 더해서 
//  나머지 배열 요소들의 값을 알아낼 수 있다.
// 
//

//// 함수 기초
//  어셈블리에서는 procedure 라고 부른다
//  특정 역할을 수행하는 박스느낌
// 
//  PRINT_MSG:
//       PRINT_SRTING msg
//       NEWLINE
//       ret
// 
//  메인함수에서 
// 
//  call PRINT_MSG  이렇게 호출하면됨
// 
// 

//// 스택 메모리
// 
//  함수에서 사용할 수 있는 변수를 
//  레지스터나 메모리에서 계속 이용한다면
//  공간이 부족해 결국 낭비현상이 일어난다.
// 
//  함수가 끝나면 다시 함수안에서 썼던 변수는
//  다시 쓸 일이 없기 때문에 임시적인 저장공간이
//  필요하다. 그곳이 바로 스택 메모리이다.
// 
//  하는 역할
// 
//  - 매개변수 전달
//  - 돌아갈 주소 관리
// 
// 
//  // 스택 메모리와 스택 프레임
// 
//  스택과 관련된 포인터 레지스터
// 
//  ip - 다음 수행 명령어의 위치
//  sp - 현재 스택의 top 위치
//  bp - 스택 상대주소 계산용
// 
// <스택 프레임>
// 
//  High  
//             1
//             2
//            RET
//         이전 BP 값    
//             ~
//             ~
//            RET
//  bp --- 이전 BP 값  --- sp
//         
//  Low
// 
//  SP는 계속해서 위치가 변한다.
//  BP는 어디까지가 프레임인지 고정시켜주는 역할인데
//  Push 와 Pop을 통해 다음 함수로 넘어갈때는 푸시하여
//  BP를 바꿔주고 다시 돌아갈 때는 팝을 하여 복원시킨다.
// 
//  아직 제대로 이해는 안가지만
//  CPP 에서 더 다뤄보고 자료구조에서도 
//  스택을 다뤄봐야 이해가 잘 갈 것 같다.
//































